---
title: 客户端缓存
date: 2021-06-28
publish: false
tags:
  - 网络通信
categories:
  - 网络通信
---

## 缓存的意义

减少请求，更多的使用本地资源，减少服务器压力

## 缓存位置

由上至下开始寻找，找到即返回；找不到则继续
Memory Cache
Disk Cache
网络请求

### memory cache

memory cache 是内存中的缓存，按照操作系统的常理：先读内存，再读硬盘。几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素，memory cache 注定只能是个“短期存储”。常规情况下，浏览器的 TAB 关闭后该次浏览的 memory cache 便告失效。memory cache 机制保证了一个页面中如果有两个相同的请求。给 Cache-Control 设置 no-store。可让资源不被 memory cache 存储。

### disk cache

disk cache 也叫 HTTP cache，顾名思义是存储在硬盘上的缓存，因此它是持久存储的，是实际存在于文件系统中的。而且它允许相同的资源在跨会话，甚至跨站点的情况下使用，例如两个站点都使用了同一张图片。

disk cache 会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，哪些资源不可以缓存；哪些资源是仍然可用的，哪些资源是过时需要重新请求的。当命中缓存之后，浏览器会从硬盘中读取资源，虽然比起从内存中读取慢了一些，但比起网络请求还是快了不少的。绝大部分的缓存都来自 disk cache。

### 网络请求

如果一个请求在上述位置没有找到缓存，那么浏览器会正式发送网络请求去获取内容。再把内容根据相关字段进行缓存

## 强缓存与协商缓存

> 强缓存

当客户端请求资源时，会先访问缓存中(disk cache)是否存在, 如果存在则直接返回；不存在则去请求资源服务器，响应后再写入缓存中。
可以设置强制缓存的字段是 Cache-control 和 Expires。

### Expires

Expires 是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)，如

```js
Expires: Thu, 10 Nov 2017 08:45:11 GMT
```

在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。

缺点：由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑自身修改，客户端与服务端的时差或者误差等因素也可能造成时间不一致，致使缓存失效。

### Cache-control

已知 Expires 的缺点之后，在 HTTP/1.1 中，增加了一个字段 Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。同 Expires 的区别就是前者是绝对时间，而后者是相对时间。如下：

```js
Cache-control: max-age=2592000
```

1.max-age： 即缓存最大有效时间。
2.no-cache： 不要缓存，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。
3.no-store： 不要缓存，memory cache 中也不存储，所有内容都不走缓存，包括强制和对比。
4.public：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)。
5.private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。

Cache-control 的优先级高于 Expires。

> 协商缓存

当强制缓存失效(超过规定时间)时，就需要使用协商缓存，由服务器决定缓存内容是否失效。
浏览器查找缓存，返回一个缓存标识。之后浏览器拿这个标识和服务器通讯。如果缓存未失效，则返回 HTTP 状态码 304 表示继续使用，于是客户端继续使用缓存；如果失效，则返回新的数据和缓存规则，浏览器响应数据后，再把规则写入到缓存数据库。

### Last-Modified & If-Modified-Since

1.服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间，例如

```js
Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT
```

2.浏览器将这个值和内容一起记录在缓存中。

3.下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 Last-Modified 的值写入到请求头的 If-Modified-Since 字段

4.服务器会将 If-Modified-Since 的值与 Last-Modified 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。

### Etag & If-None-Match

为了解决 Last-Modified & If-Modified-Since 不够精确的问题。

1.服务器通过 Etag 字段告知客户端，Etag 存储的是文件的特殊标识(一般都是 hash 生成的)

2.浏览器将这个值和内容一起记录在缓存中。

3.下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 Etag 的值写入到请求头的 If-None-Match 字段

4.服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。

Etag 的优先级高于 Last-Modified
