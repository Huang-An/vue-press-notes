(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{373:function(t,s,e){"use strict";e.r(s);var o=e(42),r=Object(o.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"js-模块化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-模块化"}},[t._v("#")]),t._v(" js 模块化")]),t._v(" "),e("h2",{attrs:{id:"commonjs"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[t._v("#")]),t._v(" CommonJS")]),t._v(" "),e("p",[t._v("Node.js 是 commonJS 规范的实现，它有四个重要的变量为模块化的实现提供支持：module、exports、require、global。实际使用时，用 module.exports 定义当前模块对外输出的接口, 用 require 加载模块。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[t._v("exports 指向 module.exports。即在 exports 上添加的属性等于添加到 module.exports 上。\n如果将 exports 指向其他对象，会切断与 module.exports 之间的指向关系。")])]),t._v(" "),e("p",[t._v("CommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。")]),t._v(" "),e("h2",{attrs:{id:"amd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[t._v("#")]),t._v(" AMD")]),t._v(" "),e("p",[t._v("AMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。require.js 是 amd 规范的实现。")])])}),[],!1,null,null,null);s.default=r.exports}}]);